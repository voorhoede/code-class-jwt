!["The Real JWT Code Class"](header.svg)

## What is JWT

- JSON Web Token
- Internetstandard: RFC 7519

> a standard for safely passing claims in space constrained environments

```javascript
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.
TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

(Whitespace added for readability)

## Related RFCs: JWS & JWE

- JSON Web Signatures
- JSON Web Encryption

A JWT is _signed_ so that it can be verified against tampering. It can be _encrypted_ so that it cannot be read without a secret and/or public-private keypair.

## What problem does it solve?

> Standardization effort in the form of a simple, optionally validated and/or encrypted, container format

It is used to make _claims_ about a certain party or object. Typically, we‚Äôre talking about:

- Authentication
- Authorization
- Federated identity (SSO)
- Client-side sessions (‚Äústateless‚Äù sessions)
- Client-side secrets

Simply said, a JWT is well-specified token format that you can use to exchange data between services in the relative safety of knowing that the data hasn‚Äôt been modified.

## JWT vs session cookies?

> If my grandmother had wheels she would have been a bike

- Cookies and JWT can‚Äôt be compared
- A cookie is a means of transport, JWT is a message format
- A session cookie is a cookie without an `Expires` property.
- So, a JWT can be stored in a cookie
- ...as well as in localStorage or sessionStorage, or a query string parameter
- Also, a cookie can be signed...
- and browsers have a ton of stuff built in to prevent malicious use of cookies.

So, what do we do?

Pick one: a _stateless_ JWT, where the state is stored inside the JWT (ex: a user id), or a _stateful_ JWT where it only contains a session id.

A _stateful_ JWT is larger (byte size) than a cookie, needs to do server work (lookup state in a Redis database, for example) and is less robust than a cookie (all kinds of vulnerabilities that are adressed by cookies, such as `httpOnly` setting) are gone when using JWT.

A _stateless_ JWT can be useful if short-lived.

## About authentication and authorization

Because JWTs carry information (`claims`) they can carry authentication (`username=harry`) and authorization (`role=admin`) information to be shared among services.

## About federated identity (SSO)

When you are building a single sign-on service with an identity provider, authentication/authorization service, resource or application server _and_ a front-end, JWT can come in handy to let these services talk to each other.

**Access and refresh tokens**: a short-lived access token can be a JWT, but a refresh token can be simply a (signed) unique identifier.

## So... when to use JWT?

> ‚ÄúIt depends!‚Äù
> ‚ÄîEvery developer everywhere all the time

YMMV, but I would recommend it only for short-lived authentication mechanisms, like getting access to resources temporarily (download link, forgot password).

## So, what does a JWT look like?

```javascript
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.
eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.
TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ
```

...which is really this:

```javascript
const header = { alg: "HS256", typ: "JWT" };
const payload = { /* claims here */ }
const jwtHeader = urlSafeBase64Encode(header);
const jwtPayload = urlSafeBase64Encode(payload);
const signature = sign(jwtHeader, jwtPayload, secret);
const myJwt = `${jwtHeader}.${jwtPayload}.${signature}`;
```

## What is URL Safe Base64 Encoding?

- It‚Äôs base64 encoding...
- ...but ‚ÄúURL safe‚Äù.
- Base64 encoding is alphanumeric (`A-Za-z0-9`) _and_ can have `+` and `/` characters*.
- JWTs can be sent in a URL, where `+` is a space and `/` is a directory delimiter. So they are replaced with `-` and `_` respectively.
- The padding character `=` (base64 strings are padded to be a multiple of 3) is removed.

\*) Because 26 √ó 2 + 10 = 62 + 2 = 64

## Why Base64?

[Because it‚Äôs safe against stupid robots](https://stackoverflow.com/a/3538079).

## JWT structure

```javascript
const myJwt = `${jwtHeader}.${jwtPayload}.${signature}`;
```

- The _header_ contains information about the jwt itself and its signing algorithm.
- The _payload_ contains any information that you want to communicate (called ‚Äòclaims‚Äô).
- The _signature_ is an encoded string, generated by taking the header, payload and a secret (or public/private keypair).

When verifying these parts, we can make sure the JWT was not tampered with between signing and verifying.

## Why is this important?

Even though the header and payload can be decoded and aren‚Äôt secure _at all_, changing them without re-signing the JWT will make the JWT fail validation. The verifying agent (a server) can then say: this has been tampered with, I am not going to authorise your.

## The header

- `alg`: the algorithm to sign the token. This is the only mandatory property.
- `typ`: the media type of the JWT; `JWT` in 99.9% of the cases
- `cty`: the content type. Must only be set if this JWT‚Äôs payload is another JWT; its value will be `JWT`

```json
{
  "alg": "HS256",
  "typ": "JWT"
}
```

There are more header claims, to be used for encrypted JWTs.

## The payload

- The payload consists of one or several properties that are called ‚Äòclaims‚Äô.
- None of them are mandatory
- Public claim are defined in the spec and can also be called ‚Äòregistered claims‚Äô
- Private claims are whatever your app needs to be in the payload.

These are the defined public claims:

- `iss`: the issuer
- `sub`: the subject
- `aud`: the intended audience of the JWT
- `exp`: the expiration time in seconds since epoch
- `nbf`: ‚Äúnot before time‚Äù, the opposite of exp, meaning the jwt should be considered valid after this timestamp
- `iat`: ‚Äúissued at time‚Äù
- `jti`: JWT identifier

The shortness of these claims are to keep the bytesize of the JWT down somewhat.

## Payload example

```json
{
  "iss": "voorhoede",
  "sub": "users",
  "aud": "admins",
  "exp": 1614890846081,
  "jti": 1,
  "username": "anne@voorhoede.nl",
  "role": "plumber"
}
```

In practice, many claims will be unused, but the more claims you make and verify, the more robust your JWT becomes.

## Security considerations

- Substitution attack: set more claims & verify all claims
- Signature stripping: don‚Äôt use unsigned JWTs
- Cross-Site Request Forgery (CSRF): use CSRF tokens, or don‚Äôt store JWT in cookie. But...
- Cross-Site Scripting (XSS): use cookies with `httpOnly` flag
- ...others?

## Best practices

- Nothing is really secure
- Don‚Äôt roll your own encryption
- Verify all claims (such as `iss` and `exp`)
- Perhaps don‚Äôt rely on the algorithm the JWT states in its header
- Pick strong secrets & keys

## Sources

- [The JWT Handbook](https://auth0.com/resources/ebooks/jwt-handbook)
- [Stop using JWT for sessions](http://cryto.net/~joepie91/blog/2016/06/13/stop-using-jwt-for-sessions/)
- [The Hard Parts of JWT Security Nobody Talks About](https://www.pingidentity.com/en/company/blog/posts/2019/jwt-security-nobody-talks-about.html)
- [Why do we use Base64? (Accepted answer on SO)](https://stackoverflow.com/questions/3538021/why-do-we-use-base64/3538079#3538079)

üëã
